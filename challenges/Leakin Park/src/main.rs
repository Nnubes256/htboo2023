use std::str::FromStr;

use indicatif::ParallelProgressIterator;
use itertools::Itertools;
use rayon::prelude::{IntoParallelRefIterator, ParallelBridge, ParallelIterator};
use rug::Integer;

/// Traducción optimizada de long_to_bytes de pycryptodome a Rust
pub fn long_to_bytes(mut n: Integer, blocksize: usize) -> Vec<u8> {
    let mut s = Vec::new();
    while n > Integer::ZERO {
        s.extend_from_slice(&n.to_u32_wrapping().to_le_bytes());
        n >>= 32;
    }
    let padding = s.iter().rev().take_while(|&&v| v == 0).count();
    let len = if blocksize != 0 {
        (s.len() - padding + blocksize) / blocksize
    } else {
        s.len() - padding
    };
    s.truncate(len);
    s.reverse();
    s
}

fn main() {
    // Datos proporcionados por el challenge
    const LEAK: &str = "148594895129134690059547203847950687592882825999960826283014952999097482938737925595291816674707800241036085665425856475315513685680562640367702192505138164016657148468712445291666471581382141113666541656452685792380607330712196064869073138445102957444587918954494331999641310131932085596922698471272605424928799431974186478525221073052594661555269352858471246587265000829881742234454159723988604193715981020412888837733011104095365794940331090202358438352534306580370698976010752050395558859035033087859388621465048684706212832334768490755540515342494323509356201836648987652127932603531726999505199869015549017796890615442669584376162872845357358337680870405148819188833766837535343384693913172946197995991829256794273539359338813969012673542633416956875876215602171201647981919951269178692094248096186472498440179555280513489225207207215076179312615724522915774412681750039866027209631147216541208463363118769001302510555424321184046146842917265631305526941642763957605518241971858150068532998530388652454807191451214185391013187704543931511976882587339767632226832392058888076922365876164561950572466497284413232241215959127083771565765758500275835784358976172838233043672460866769783586215730549467646283804526627897398944509777655702140237258200139207381102331416866714638403196839070012779844319073932401486093414429010150556678300567012253205486304682344584670126200728204690964147878011992402418910905970445927036896985091976685493847446586156843034026584764573263245656050592719511812237587907874151619901724915998094547798739946731021748451346662136896002596360409980399787118422460165401462227010751387613717071794503201537991501686703981947580155554255837327787285820310483552202512711408988478284297240437670792292494053953515968140289742714146674985610357071098511610535536380348055990254741116447964047603421980961338799092345349689606411912779153460340389306531741336962559890739330867023744276257330962627149176521970233737012452390803747383691465617928274805570569270621075630316757978514206144480906840820537204094574337167976566967454561757514391779092332484565254073134162605541511123342917144001160230946381042875662031886635948102979501523282922399174127050375845618335743430513902244167200371919264466829792096012138922198720633386902214504038636973247767246124323453708321763378441119334400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    const E: i32 = 0x10001;
    const CIPHERTEXT: &str = "110692588097983692099237158267493751508996612000799850973565163921412900992859133512948163000401341540639958819775217733431382703698700034602452982525117455678232430040423943254436515236217566777381657399017439895510488773737362803195888619627634118446244001536760527820498330390413310887810434123801734471285203920665027814144335923275315151021506400262049598585189252317485047358242388473069503823966479225987604301910063641326575849953603432951714100043162705216223885135093972069019977478205433687891870076630089170067082140329898527894806282220169347273089034641603192460286449225990194611762473935044573787873017158755802396630943668662665982781349250854136057380841977323185315430000374273158777573308825000543228531569597911483236720420932419496455726261701621753571502054471069922187517711346170831740177177800964691166154989694877544242809761065319954382740945368025493630036993347212745756654188061907913347280551335321503048800908465271620221560129536411982180473256781117009463636292073907986248303606987468178515557368259566362961190464800134304379304092074114655136460935849121240488889055597941382598445958216476634262988603220247573766738844394269271144393007799955740107973417159759000538575205040439116655528134324989307902924288288829128930191421709122264506550426367001933552139541996513707364496550417114643659348865328531634977950520109672273765326314330778546544015182923196742578137498245419634103531473486728386751185421759258589684857172352948465608746049548127044262127495638743430419942926284630831396380261281260823602743148792956523918678119754166693059693366237425712717598266908440029964116679392727687691270166242679319835573230519965528385022082897725489110360332452348600489409148050504998332828986781306273019081410674317691567030570115616792411870284634349789759059347838128792750009141526691931840706202646146535478023235000815243085118296469314360838965784097654038421911663825022949794819839363749121057341549353179248982836022381423904540997683577013111478371969060516312468990055586259657993137128401227775977247561171876772462688292476165991104352341782896685829346615721876872471415019479508022318025666035457644374196200386232520840959114919586959529350718417200186839114630352189868247218285741498019833978972690937101819257667663330651381022326179072720634670492594256233663453987506306233254615987110736054347699080922735353215116152385618974196536877968857687481306186723067012869684822188168730775862585414739198280387835075763802102204797248328770499007582291956681727021779026025693380073441477710868897408062710746376279636516707880066628686109779738179281333953280891983302695443334849493696262050023736754598";

    let leak = Integer::from_str(LEAK).unwrap();
    let ciphertext = Integer::from_str(CIPHERTEXT).unwrap();

    // 1. Buscamos una factorización válida (N=8) de `leak` a partir de los factores
    //    de factors()

    // OPT: si bien se puede hacer fuerza bruta con todos los factores primos de 1 a 255
    // que saca la función factors() del problema, también puede realizarse un análisis
    // estadístico de lo que saca getPrime(8) de pycryptodome y darse cuenta de que ni
    // siquiera te saca todos los primos de 1 a 255.
    //
    //      def factors():
    //          return [getPrime(int(math.log2(MAX))) for i in range(int(math.log2(MAX)))]
    //
    //      probable_factors = set()
    //      while True:
    //          probable_factors.add(getPrime(int(math.log2(MAX))))
    //
    let probable_factors = &[
        131u32, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,
        227, 229, 233, 239, 241, 251,
    ];

    // Montamos una caché con los factoriales (N - 1)! de todos los factores posibles
    println!("[*] Caching factorials of factors");
    let cached_factorials: Vec<_> = probable_factors
        .iter()
        .map(|&x| {
            let mut numb: Integer = 1u32.into();
            for i in 2..x {
                numb *= i;
            }
            numb
        })
        .collect();

    // Buscamos una factorización válida (N=8) de `leak` con los factoriales de los factores
    // identificados.
    println!("[*] Cracking factor list...");
    let count = cached_factorials
        .iter()
        .combinations_with_replacement(8)
        .count();
    let iter = cached_factorials.iter().combinations_with_replacement(8);
    let res = iter
        .par_bridge() // OPT: paralelizar a todos los núcleos con `rayon` :)
        .progress_count(count as u64) // Post-challenge: barra de progreso
        .find_any(|factorials| {
            let mut numb: Integer = 1u32.into();
            for &i in factorials {
                numb *= i;
            }
            numb == leak
        });

    let Some(valid_factorials) = res else {
        println!("[!] Not found :(");
        return;
    };
    // Obtenemos los factores originales para mostrarlos
    let resolved_factors: Vec<_> = valid_factorials
        .iter()
        .map(|v| cached_factorials.iter().position(|r| r == *v).unwrap())
        .map(|idx| probable_factors[idx])
        .collect();
    println!("[+] Found: {resolved_factors:?}");

    // 3. Tenemos una factorización válida, de la cual podemos sacar `p` y `q`. Sin embargo,
    //    el `p` y `q` que se calcula de dicho `leak` depende del orden de sus factores.
    //    Por tanto hay que cribar, a partir de las combinaciones de factores posibles,
    //    un `p` y `q` que aplicado al texto cifrado nos de la flag.
    println!("[*] Finding p and q which gives the flag...");

    // OPT: `p` es el siguiente primo del producto de los 4 primeros factores,
    //      `q` es el siguiente primo del producto de los 8 factores, dividido entre `p`.
    // Puesto que el producto de los 8 factores es `leak`, podemos centrarnos en crackear
    // `p` (realizando combinaciones de 4 de los 8 factores) y computar `q` adrede, lo cual
    // reduce el espacio de búsqueda a 70 combinaciones (50 únicas debido a repetidos).
    // Con la paralelización automática de iteradores que proporciona `rayon` y 8 núcleos
    // se tarda aproximadamente 1 minuto en recorrer todo el espacio de combinaciones.
    let factor_combinations: Vec<_> = valid_factorials.iter().combinations(4).collect();
    let result = factor_combinations
        .par_iter() // OPT: paralelizar búsqueda a todos los núcleos con `rayon` :)
        .map(|superfactors| {
            // Sacamos el producto de los 4 primeros factores
            let mut numb: Integer = Integer::ONE.clone();
            for &&i in superfactors {
                numb *= i;
            }

            // Derivamos `p`, y de `p` derivamos `q`
            let p = numb.next_prime();
            let q_base = leak.clone() / p.clone();
            let q = q_base.next_prime();

            // Derivamos los parámetros RSA correspondientes y probamos a desencriptar
            let n = p.clone() * q.clone();
            let phi = (p - Integer::ONE) * (q - Integer::ONE);
            let e = Integer::from(E);
            let Ok(d) = e.invert(&phi) else {
                panic!();
            };
            let Ok(decrypted) = ciphertext.clone().pow_mod(&d, &n) else {
                panic!();
            };

            // Devolvemos la cadena resultante...
            // Lo que se hizo en el challenge original fue directamente devolver una
            // lista de `decrypted`s por consola y cribar la lista manualmente
            // (puesto que el bigint con la flag es notablemente más pequeño que los demás)
            // Extensión post-challenge: decodificar el plaintext...
            String::from_utf8_lossy(&long_to_bytes(decrypted, 0)).to_string()
        })
        .progress() // Post-challenge: barra de progreso
        // Extensión post-challenge: en vez de devolver una lista de factores, automáticamente
        // cribar por la flag, y parar si se encuentra
        .find_any(|decrypted_str| decrypted_str.starts_with("HTB{"));

    if let Some(s) = result {
        println!("[+] Found, here's your flag: {s}");
    } else {
        println!("[!] Not found :(")
    }
    //println!("{:#?}", res);
}
